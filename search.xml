<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【SpringBoot】配置文件</title>
    <url>/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><ul>
<li><p>SpringBoot使用一个全局的<font color="#FF0000">配置文件</font>，配置文件名是固定的。</p>
<ul>
<li><strong>application.properties</strong>   </li>
<li><strong>application.yml</strong>  </li>
</ul>
</li>
<li><p><font color="#FF0000">配置文件</font>的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好。</p>
<a id="more"></a>  
<ul>
<li><strong>application.properties</strong><br>用Spring Initializr新建一个SpringBoot项目，则配置文件<code>application.properties</code>在<code>/src/main/resources</code>目录下。可写入需要的配置：  <img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-0.png" class></li>
<li><strong>application.yml</strong><br>同目录下可新建配置文件<code>application.yml</code>：<pre><code>server:
port: 8081
</code></pre>
</li>
</ul>
</li>
<li><p><font color="#FF0000">YAML</font>（YAML Ain’t Markup Language）不仅是一个标记语言。</p>
</li>
<li><p><font color="#FF0000">标记语言</font>：以前的配置文件大多都使用的是<code>xxxx.xml</code>文件；  </p>
</li>
<li><p><font color="#FF0000">YAML</font>：以数据为中心，比json、xml等更适合做配置文件。</p>
<pre><code>server:
port: 8081
</code></pre>

</li>
</ul>
<ul>
<li><font color="#FF0000">XML</font>：需要更多标签。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">   &lt;port&gt;8081&lt;&#x2F;port&gt;</span><br><span class="line">&lt;&#x2F;server&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><code>key: value</code>：表示一对键值对（空格必须有）；空格作为缩进以控制层级。</p>
<pre><code>server:
   port: 8081
   path: /hello
</code></pre>

<h2 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h2><ul>
<li><strong>字面量：普通的值（数字，字符串，布尔）</strong>  <ul>
<li><font color="#FF0000">字符串不用加引号；  双引有用单无用；</font></li>
<li>双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思；<br><code>name: &quot;tom \n jane&quot;</code>  输出：<code>tom 换行 jane</code>  </li>
<li>单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据；<br><code>name: ‘tom \n jane’</code> 输出：<code>tom \n jane</code></li>
</ul>
</li>
<li><strong>对象/Map</strong><pre><code>friends:
  lastName: zhangsan
  age: 20
friends: {lastName: zhangsan,age: 18}
</code></pre></li>
<li><strong>List/Set</strong>  <pre><code>pets:
‐ cat
‐ dog
‐ pig
pets: [cat,dog,pig]
</code></pre>

</li>
</ul>
<h1 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h1><h2 id="本节要点"><a href="#本节要点" class="headerlink" title="本节要点"></a>本节要点</h2><img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-12.png" class>

<h2 id="Dog类"><a href="#Dog类" class="headerlink" title="Dog类"></a>Dog类</h2><p><code>com.example.spring_boot_04_config.bean</code>下新建Dog类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure>

<p><code>Alt + Insert</code>键入所有变量的<code>getter</code>和<code>setter</code>，以及<code>toString()</code>。  </p>
<h2 id="用-ConfigurationProperties将Person类与配置文件属性绑定"><a href="#用-ConfigurationProperties将Person类与配置文件属性绑定" class="headerlink" title="用@ConfigurationProperties将Person类与配置文件属性绑定"></a>用<font color="#FF0000">@ConfigurationProperties</font>将Person类与<font color="#FF0000">配置文件属性</font>绑定</h2><p><code>com.example.spring_boot_04_config.bean</code>下新建Person类：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment">* prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>
<p><code>Alt + Insert</code>键入所有变量的<code>getter</code>和<code>setter</code>，以及<code>toString()</code>。</p>
<ul>
<li><p><font color="#FF0000">@ConfigurationProperties(绑定配置文件的属性到类的属性)</font>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定。<br>但由于只有这个组件是容器中的组件，才能容器提供的<code>@ConfigurationProperties</code>功能，因此，需要先把Person设置为容器中的组件，也就是<code>@Component</code>的功能。  </p>
</li>
<li><p><font color="#FF0000">@Component(绑定类到容器)</font>：把普通POJO实例化到Spring容器中，相当于配置文件中的 <code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code>。<br>泛指各种组件，就是说当我们的类（此处的Person类）不属于各种归类的时候（不属于<code>@Controller</code>、<code>@Services</code>等的时候），我们就可以使用<code>@Component</code>来标注这个类。  </p>
</li>
<li><p><font color="#FF0000">POJO</font>：普通的JavaBeans(简单的实体类)，具有一部分<code>getter</code>/<code>setter</code>方法。  </p>
</li>
</ul>
<h2 id="用-Value将Person类与指定属性绑定"><a href="#用-Value将Person类与指定属性绑定" class="headerlink" title="用@Value将Person类与指定属性绑定"></a>用<font color="#FF0000">@Value</font>将Person类与<font color="#FF0000">指定属性</font>绑定</h2><p><code>com.example.spring_boot_04_config.bean</code>下新建Person类：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "person")</span></span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">  * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#</span></span><br><span class="line"><span class="comment">  &#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">  * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">  <span class="comment">//@Email</span></span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;person.lastName&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"#&#123;11*2&#125;"</span>)</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"true"</span>)</span><br><span class="line">  <span class="keyword">private</span> Boolean boss;</span><br><span class="line">  <span class="keyword">private</span> Date birth;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">  <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<h2 id="依赖写入pom-xml文件"><a href="#依赖写入pom-xml文件" class="headerlink" title="依赖写入pom.xml文件"></a>依赖写入pom.xml文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!‐‐导入配置文件处理器，配置文件进行绑定就会有提示‐‐&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring‐boot‐configuration‐processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<h2 id="全局配置文件：application-yml"><a href="#全局配置文件：application-yml" class="headerlink" title="全局配置文件：application.yml"></a>全局配置文件：application.yml</h2><pre><code>person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - tom
      - jane
    dog:
      last-name: 小狗
      age: 12
</code></pre>

<p>由于<code>pom.xml</code>文件中存在配置文件处理器，因此即使使用的是<code>last-name</code>而不是<code>lastName</code>，依然能成功绑定。   </p>
<h2 id="Tests文件"><a href="#Tests文件" class="headerlink" title="Tests文件"></a>Tests文件</h2><p>在<code>test</code>目录下的<code>SpringBoot04ConfigApplicationTests</code>文件中，更新下列代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringBoot04ConfigApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Person person;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#FF0000">@Autowired(将容器中的类装配给指定对象)</font>：使用<code>@Autowired</code>时，首先在容器中查询对应类型的bean（因此该类需要提前用<code>@Component</code>将类放到容器中），将该bean装配给<code>@Autowired</code>指定的数据。</p>
<ul>
<li><p>随后进行测试，用<code>@ConfigurationProperties</code>的Person类成功输出<font color="#FF0000">配置文件中</font>设好的数据：  </p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-1.png" class>
</li>
<li><p>随后进行测试，用<code>@Value</code>的Person类则输出Person类中<font color="#FF0000">指定的</font>数据：  </p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-2.png" class>

</li>
</ul>
</li>
</ul>
<h2 id="其他业务逻辑"><a href="#其他业务逻辑" class="headerlink" title="其他业务逻辑"></a>其他业务逻辑</h2><p>写一个controller类,用<code>@Value</code>获取配置文件中的某项值：  </p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-3.png" class>  
<p>随后在web应用中输出：  </p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-4.png" class> 

<h2 id="用-PropertySource与person-properties文件代替全局配置文件"><a href="#用-PropertySource与person-properties文件代替全局配置文件" class="headerlink" title="用@PropertySource与person.properties文件代替全局配置文件"></a>用<font color="#FF0000">@PropertySource</font>与<font color="#FF0000">person.properties</font>文件代替全局配置文件</h2><p>考虑到全局配置文件不宜过度冗长，因此考虑使用多个配置文件<code>xxx.properties</code>替代。<br>如将全局配置文件<code>application.properties</code>与<code>application.yml</code>中关于person的属性注释掉后，将下述需要的属性写入<code>resources</code>下的一个配置文件<code>person.properties</code>：  </p>
<pre><code>  person.lastName=Allen
  person.age=18
  person.boss=false
  person.birth=2017/12/12
  person.maps.k1=v1
  person.maps.k2=12
  person.lists=tom,jane
  person.dog.last-name=小狗
  person.dog.age=13
</code></pre>

<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-5.png" class> 

<p>并在person类中用<font color="#FF0000">@PropertySource</font>加载指定的配置文件<code>person.properties</code>：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="line"> * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span><br><span class="line"> * prefix &#x3D; &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射</span><br><span class="line"> *</span><br><span class="line"> * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@PropertySource(value &#x3D; &#123;&quot;classpath:person.properties&quot;&#125;)</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String lastName;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean boss;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Map&lt;String,Object&gt; maps;</span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line">    private Dog dog;</span><br></pre></td></tr></table></figure>

<p>测试一下，成功注入：  </p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-6.png" class>  

<h2 id="用-ImportResource导入Spring的配置文件"><a href="#用-ImportResource导入Spring的配置文件" class="headerlink" title="用@ImportResource导入Spring的配置文件"></a>用<font color="#FF0000">@ImportResource</font>导入<font color="#FF0000">Spring的配置文件</font></h2><p>首先创建一个HelloService组件：</p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-8.png" class>  
<p>随后创建以一个Spring的配置文件<code>beans.xml</code>：</p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-7.png" class> 
<p>在配置文件<code>beans.xml</code>中加入HelloService组件：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;HelloService&quot; class&#x3D;&quot;com.example.spring_boot_04_config.service.HelloService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>并在<code>Test</code>文件中测试Spring IOC容器中此时能否自动识别配置文件中的组件：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringBoot04ConfigApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloServive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(ioc.containsBean(<span class="string">"HelloService"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>返回false，说明此时是无法自动识别的。<br>也就是说Spring Boot里面既没有Spring的配置文件，我们自己编写的Spring配置文件也不能自动识别。<br>想让Spring的配置文件生效，需要使用<font color="#FF0000">@ImportResource</font>标注在一个主程序或者配置类上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot04ConfigApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>此时成功返回true。</p>
<h2 id="【推荐用法】用-Bean给容器中添加组件，用配置类来替代Spring的配置文件"><a href="#【推荐用法】用-Bean给容器中添加组件，用配置类来替代Spring的配置文件" class="headerlink" title="【推荐用法】用@Bean给容器中添加组件，用配置类来替代Spring的配置文件"></a>【推荐用法】用<font color="#FF0000">@Bean</font>给容器中添加组件，用<font color="#FF0000">配置类</font>来替代Spring的配置文件</h2><p>首先创建一个专门的配置类：  </p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-9.png" class>   
<p>使用<font color="#FF0000">@Configuration</font>声明当前类（即MyAppConfig）是一个配置类，用<font color="#FF0000">@Bean</font>将方法的返回值（即HelloService()）作为组件添加到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">HelloService2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以使上一小节的Spring配置文件<code>beans.xml</code>失效，即注释掉在主程序或者配置类上的<code>@ImportResource</code>标注：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\@ImportResource(locations &#x3D; &#123;&quot;classpath:beans.xml&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>此时配置类就完全取代了上一节中Spring配置文件<code>beans.xml</code>的作用了：</p>
<img src="/2020/01/28/%E3%80%90SpringBoot%E3%80%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/pasted-10.png" class>]]></content>
  </entry>
  <entry>
    <title>【SpringBoot】SpringBoot安装及使用</title>
    <url>/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>SpringBoot创建<font color="#FF0000">独立的Spring</font>应用程序；<font color="#FF0000">简化Maven配置</font>，开箱即用；<font color="#FF0000">内嵌式容器Tomcat</font>简化Web项目，没有冗余代码生成和XML配置的要求。<br>本章主要目标完成SpringBoot基础项目的构建，并且实现一个简单的http请求处理，即<font color="#FF0000">浏览器发送一个hello请求，服务器接收请求并处理，响应一个Hello World字符串</font>。</p>
<a id="more"></a>

<h1 id="HelloWorld入门"><a href="#HelloWorld入门" class="headerlink" title="HelloWorld入门"></a>HelloWorld入门</h1><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ul>
<li><strong>安装JDK</strong></li>
<li><strong>安装Maven</strong></li>
<li><strong>安装IntelliJ IDEA</strong></li>
</ul>
<h2 id="使用Spring-Initializr创建SpringBoot项目"><a href="#使用Spring-Initializr创建SpringBoot项目" class="headerlink" title="使用Spring Initializr创建SpringBoot项目"></a>使用Spring Initializr创建SpringBoot项目</h2><ul>
<li><p><strong>使用Spring Initializr创建</strong>  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-1.png" class>
</li>
<li><p><strong>在Artifact中给项目命名</strong>  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-4.png" class>
</li>
<li><p><strong>选择web项目</strong>  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-5.png" class>  
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-6.png" class>
</li>
<li><p><strong>创建完成</strong><br>点击图中第七行的运行按钮：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-38.png" class>  
<p>运行成功：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-8.png" class>  
<p>此时访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，可以出现文字了：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-10.png" class>



</li>
</ul>
<h2 id="使用Maven创建SpringBoot项目"><a href="#使用Maven创建SpringBoot项目" class="headerlink" title="使用Maven创建SpringBoot项目"></a>使用Maven创建SpringBoot项目</h2><ul>
<li><p><strong>使用Maven创建</strong>  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-18.png" class>
</li>
<li><p><strong>导入spring boot相关依赖</strong><br>从Spring官网的<a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">guides</a>或<a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">Getting start</a>中复制如下到<code>pom.xml</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>.RELEASE&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">    &lt;relativePath/</span>&gt; &lt;!-- lookup parent <span class="keyword">from</span> repository --&gt;</span><br><span class="line">&lt;<span class="regexp">/parent&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;dependencies&gt;</span></span><br><span class="line"><span class="regexp">    &lt;dependency&gt;</span></span><br><span class="line"><span class="regexp">        &lt;groupId&gt;org.springframework.boot&lt;/g</span>roupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;<span class="regexp">/artifactId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>dependency&gt;</span><br><span class="line">&lt;<span class="regexp">/dependencies&gt;</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-19.png" class>
</li>
<li><p><strong>编写主程序</strong><br>新建包和主程序：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-20.png" class>  
<p>主程序用于启动Spring Boot应用：</p>
<pre><code> /*
  用SpringBootApplication来标注一个主程序类，说明这是一个Spring Boot应用
 */
@SpringBootApplication
public class SpringBoot02HelloworldApplication {
    public static void main(String[] args) {
        //启动spring应用
        SpringApplication.run(SpringBoot02HelloworldApplication.class, args);
    }
}
</code></pre> 
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-21.png" class>
</li>
<li><p><strong>创建完成</strong><br>点击图中第十行的运行按钮： </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-37.png" class>   
<p>运行成功：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-8.png" class>    
<p>此时访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，可以出现文字了：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-10.png" class>  

</li>
</ul>
<h2 id="使用Spring官网创建SpringBoot项目"><a href="#使用Spring官网创建SpringBoot项目" class="headerlink" title="使用Spring官网创建SpringBoot项目"></a>使用Spring官网创建SpringBoot项目</h2><ul>
<li><p><strong>利用官网创建</strong><br>在Spring官网的<a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a>下，选择快速创建：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-31.png" class>   
<p>在Artifact中给项目命名：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-30.png" class>   
<p>在依赖中勾选Spring Web，并选择生成:  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-33.png" class> 
</li>
<li><p><strong>解压到本地后，导入到Idea中，创建完成</strong><br>点击图中第七行的运行按钮：</p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-35.png" class>   
<p>运行成功：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-8.png" class>    
<p>此时访问<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，可以出现文字了：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-10.png" class> 

</li>
</ul>
<h2 id="写一个controller查看前后端交互信息"><a href="#写一个controller查看前后端交互信息" class="headerlink" title="写一个controller查看前后端交互信息"></a>写一个controller查看前后端交互信息</h2><ul>
<li><p><strong>主程序的同级目录中new一个package</strong>  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-12.png" class> 
</li>
<li><p><strong>controller的目录下new一个class</strong>  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-13.png" class> 
</li>
<li><p><strong>在类中添加注解方法一</strong><br>为HelloController类添加<font color="#FF0000">RestController</font>注解，向SpringBoot说明这是用于响应网络请求的类，其中@RestController就是<font color="#FF0000">@Controller + @ResponseBody </font>注解的综合，后无需再加<font color="#FF0000">ResponseBody </font>；<br>通过<font color="#FF0000">GetMapping/RequestMapping</font>注解，向SpringBoot说明可以响应/hello的Get请求。 </p>
<pre><code> /*
  通过RestController注解，向SpringBoot说明这是一个响应网络请求的类。
 */
@RestController
public class HelloController {

    /*
      通过GetMapping/RequestMapping注解，向SpringBoot说明可以应/hello的Get请求。
      由于类使用的RestController就是Controller + ResponseBody，因此返回的无需加@ResponseBody注解。
     */
    @GetMapping(value = "/hello")
    public String hello() {
        return "Hello World!!!";
    }
}
</code></pre>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-24.png" class> 
</li>
<li><p><strong>在类中添加注解方法二</strong><br>为HelloController类添加<font color="#FF0000">Controller</font>注解，向SpringBoot说明这是用于响应网络请求的类，后<font color="#FF0000">需加ResponseBody</font>；<br>通过<font color="#FF0000">GetMapping/RequestMapping + ResponseBody</font>注解，向SpringBoot说明可以响应/hello的Get请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello World!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-22.png" class>  
</li>
<li><p><strong>运行</strong><br>再次点击图中第七行的运行按钮： </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-38.png" class>  
<p>此时访问<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a> ，可以出现文字了：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-15.png" class>


</li>
</ul>
<h2 id="将应用打包成一个可执行的jar包"><a href="#将应用打包成一个可执行的jar包" class="headerlink" title="将应用打包成一个可执行的jar包"></a>将应用打包成一个可执行的jar包</h2><ul>
<li><p><strong>使用maven方法需手动添加插件到pom.xml文件</strong><br>将<a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">guides</a>中pom.xml中的相关内容，写入依赖之后：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>在右侧的maven中找到package的位置，双击生成jar包</strong>   </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-26.png" class>  
<p>若此处报错，注意检查User settings file的路径：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-25.png" class>  
<p>得到的jar包在target目录下：  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-27.png" class>
</li>
<li><p><strong>直接执行jar包</strong><br>扔到任意路径下后，在cmd的该路径下，执行<code>java -jar 包名</code>成功即完成炸包。  </p>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-28.png" class>

</li>
</ul>
<p>上一篇文章介绍了Spring Boot的安装及使用一个简单的web应用。本文主要介绍了这个Hello World请求的细节实现。</p>
<h1 id="Hello-World探究"><a href="#Hello-World探究" class="headerlink" title="Hello World探究"></a>Hello World探究</h1><h2 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h2><ul>
<li><p><strong>父项目</strong><br>在<code>pom.xml</code>中可以得到Spring Boot场景启动器的父项目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>.RELEASE&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">    &lt;relativePath/</span>&gt; &lt;!-- lookup parent <span class="keyword">from</span> repository --&gt;</span><br><span class="line">&lt;<span class="regexp">/parent&gt;</span></span><br></pre></td></tr></table></figure>
<p>对上述<code>spring-boot-starter-parent</code>，使用<code>ctrl+Enter</code>，跳转到该父项目的父项目： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;<span class="regexp">/groupId&gt;</span></span><br><span class="line"><span class="regexp">    &lt;artifactId&gt;spring-boot-dependencies&lt;/</span>artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.4</span>.RELEASE&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">    &lt;relativePath&gt;../</span>../spring-boot-dependencies&lt;<span class="regexp">/relativePath&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>parent&gt;</span><br></pre></td></tr></table></figure>
<p>其位于文件<code>spring-boot-starter-parent-2.2.4.RELEASE.pom</code>中。</p>
</li>
<li><p><strong>保存的依赖</strong><br>在<code>pom.xml</code>中可以得到Spring Boot场景启动器的依赖，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>其中，<code>spring-boot-starter</code> <code>-web</code>：Spring Boot场景启动器；帮助导入web模块正常运行所需组件。<br>Spring Boot将所有功能场景都抽取出来，做成一个个starters（启动器），只要在项目里引用相关starter就可以把相关场景的所有依赖导入进来。</p>
</li>
</ul>
<h2 id="主程序类-主入口类"><a href="#主程序类-主入口类" class="headerlink" title="主程序类/主入口类"></a>主程序类/主入口类</h2><ul>
<li>@SpringBootApplication<pre><code>  /*
  用SpringBootApplication来标注一个主程序类，说明这是一个Spring Boot应用
 */
<font color="#FF0000">@SpringBootApplication</font>
public class SpringBoot02HelloworldApplication {
    public static void main(String[] args) {
        //启动spring应用
        SpringApplication.run(SpringBoot02HelloworldApplication.class, args);
    }
}
</code></pre> 
<font color="#FF0000">@用SpringBootApplication来标注一个主程序类</font>：用Spring Boot应用来标注某个类，说明这个类是Spring Boot应用的主配置类，Spring Boot就应该运行这个类的main方法来启动应用。  <pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
<font color="#FF0000">@SpringBootConfiguration</font>
<font color="#FF0000">@EnableAutoConfiguration</font>
@ComponentScan(
  excludeFilters = {@Filter(
  type = FilterType.CUSTOM,
  classes = {TypeExcludeFilter.class}
), @Filter(
  type = FilterType.CUSTOM,
  classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
</code></pre>  
<ul>
<li>@SpringBootConfiguration<br><font color="#FF0000">@SpringBootConfigurations Spring Boot的配置类/配置文件</font>：<br>标注在某个类上，表示这是一个Spring Boot的配置类；<br>需要用@Configuration来标注这个注解。  </li>
<li>@EnableAutoConfiguration<br><font color="#FF0000">@EnableAutoConfiguration开启自动配置功能</font>：<br>以前我们需要配置的东西，Spring Boot帮我们自动配置；<br>@EnableAutoConfiguration告诉Spring Boot要开启自动配置功能，这样才能生效；   <pre><code>@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
</code></pre>  
<ul>
<li>@AutoConfigurationPackage<br><font color="#FF0000">@AutoConfigurationPackage</font>：自动配置包；  <ul>
<li><font color="#FF0000">@Import({Registrar.class})</font>：<br>Spring的底层注解@Import，给容器中导入一个组件；<br>导入的组件由Registrar.class将主配置类（@SpringBootApplication）所在包及其所有子包扫描到Spring容器。  </li>
</ul>
</li>
<li>@Import({AutoConfigurationImportSelector.class})<br><font color="#FF0000">@Import({AutoConfigurationImportSelector.class})</font>：给容器中导入组件；<br>AutoConfigurationImportSelector.class：导入哪些组件的选择器；<br>将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；<br>会给容器中导入非常多的自动配置类（XXXAutoConfiguration）就是给这容器中导入这个场景所需要的全部组件，并配置好这些组件。  <img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-40.png" class>  
有了自动配置了就免去了手动编写配置注入功能组件等的工作；<br>其中有：<code>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, ClassLoader);</code>  </li>
</ul>
</li>
</ul>
</li>
<li>可以看出Spring在类路径<code>META-INF/spring.factories</code>下获取<code>EnableAutoConfiguration</code>指定的值。<font color="#FF0000">将这些值作为自动配置类导入到容器中，自动配置类就自动帮助我们完成配置工作。</font></li>
</ul>
<img src="/2020/01/24/%E3%80%90SpringBoot%E3%80%91SpringBoot%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/pasted-2.png" class> 

<h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>关于Spring Boot的安装使用，也可以查看其他关于Spring Boot相关文章。<br><a href="https://www.bilibili.com/video/av38657363?p=4" target="_blank" rel="noopener">SpringBoot_2019权威教程_spring boot_springboot核心篇+springboot整合篇</a><br><a href="https://www.cnblogs.com/Sarah-Strawberry/p/11088708.html" target="_blank" rel="noopener">搭建一个入门springboot工程（Spring Initializr创建方式）</a><br><a href="https://www.cnblogs.com/anywherego/p/9591706.html" target="_blank" rel="noopener">SpringBoot实战（一）HelloWorld</a><br><a href="http://blog.didispace.com/spring-boot-learning-1/" target="_blank" rel="noopener">Spring Boot快速入门</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】Hexo+github搭建github博客</title>
    <url>/2020/01/22/%E3%80%90Hexo%E3%80%91Hexo-github%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。方便部署到github上搭建博客。  </p>
<a id="more"></a>

<h1 id="创建个人博客"><a href="#创建个人博客" class="headerlink" title="创建个人博客"></a>创建个人博客</h1><h2 id="在gitHub上new一个repository"><a href="#在gitHub上new一个repository" class="headerlink" title="在gitHub上new一个repository"></a>在gitHub上new一个repository</h2><img src="/2020/01/22/%E3%80%90Hexo%E3%80%91Hexo-github%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/pasted-0.png" class title="This is an test image">

<h2 id="git-clone将创建的repository到本地"><a href="#git-clone将创建的repository到本地" class="headerlink" title="git clone将创建的repository到本地"></a>git clone将创建的repository到本地</h2><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><ul>
<li><strong><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">官网下载</a></strong>  </li>
<li><strong>配置环境变量：</strong><br>系统变量<code>NODE_PATH</code>，即压缩后的路径，如，<code>D:\NodeJS</code>。<br>系统变量<code>PATH</code>，新增，<code>%NODE_PATH%</code>。  </li>
<li><strong>检测node.js和npm是否安装成功</strong>：<br>输入<code>node -v</code>和<code>npm -v</code>。  </li>
</ul>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul>
<li><strong>下载</strong><br>自定义路径，如，<code>D:\hexo</code> 中打开<code>git bash</code>，输入<code>npm install -g hexo-cli</code>。<br>注：cmd中没有成功。</li>
<li><strong>配置环境变量：</strong><br>系统变量<code>PATH</code>，新增，如，<code>D:\hexo\node_modules\.bin</code>。    </li>
<li><strong>检测hexo是否安装成功</strong>：<br>输入<code>hexo -v</code>。  </li>
</ul>
<h1 id="搭建本地博客"><a href="#搭建本地博客" class="headerlink" title="搭建本地博客"></a>搭建本地博客</h1><h2 id="初始化博客框架"><a href="#初始化博客框架" class="headerlink" title="初始化博客框架"></a>初始化博客框架</h2><p>在<code>E:\cymbym.github.io</code>目录下，输入<code>hexo init</code>，会自动生成本地文件。</p>
<h2 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h2><ul>
<li><strong>设置站点名、作者昵称和站点描述等</strong><br>打开根目录下的<code>_config.yml</code>修改即可。</li>
<li><strong>NexT主题的安装</strong><br>根目录下输入<code>git clone https://github.com/theme-next/hexo-theme-next themes/next</code>即可。</li>
<li><strong>NexT主题的安装</strong><br>根目录下的<code>_config.yml</code>,查找<code>theme</code>字段，将字段改为<code>theme: next</code>。<a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener">更多可参考</a>。 </li>
</ul>
<h2 id="增加search功能"><a href="#增加search功能" class="headerlink" title="增加search功能"></a>增加search功能</h2><ul>
<li><p><strong>安装hexo-generator-searchdb</strong><br>项目根目录下输入<code>npm install hexo-generator-searchdb --save</code>  </p>
</li>
<li><p><strong>增加根目录_config.yml文档中search的配置</strong><br>文档末输入 :</p>
<pre><code>search:
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre>
</li>
<li><p><strong>修改theme/next目录下_config.yml文档中local_search的配置</strong>  </p>
<pre><code># Local search
local_search:
  enable: true
</code></pre>

</li>
</ul>
<h2 id="设置预览摘要"><a href="#设置预览摘要" class="headerlink" title="设置预览摘要"></a>设置预览摘要</h2><p>只要在文章中加上<code>&lt;!--more--&gt;</code>标记 ，该标记以后部分就不在显示了。  </p>
<h2 id="将网站部署到个人的GitHub-Pages上"><a href="#将网站部署到个人的GitHub-Pages上" class="headerlink" title="将网站部署到个人的GitHub Pages上"></a>将网站部署到个人的GitHub Pages上</h2><ul>
<li><p><strong>安装hexo-deployer-git</strong><br>项目根目录下输入<code>npm install hexo-deployer-git --save</code>  </p>
</li>
<li><p><strong>增加根目录_config.yml文档中deploy的配置</strong><br>文档末输入 :</p>
<pre><code>deploy:
  type: git
  repository: https://github.com/cymbym/cymbym.github.io
  branch: master
</code></pre>
</li>
<li><p><strong>将本地的静态网页部署到服务器上</strong><br><code>hexo deploy</code>/<code>hexo d</code></p>
</li>
</ul>
<h2 id="修改与发布"><a href="#修改与发布" class="headerlink" title="修改与发布"></a>修改与发布</h2><ul>
<li><strong>清空缓存</strong><br><code>hexo clean</code>/<code>hexo cl</code>  </li>
<li><strong>生成静态文件</strong><br><code>hexo generate</code>/<code>hexo g</code></li>
<li><strong>启动服务器，本地预览博客效果</strong><br><code>hexo server</code>/<code>hexo s</code><br>在 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 中访问。</li>
</ul>
<h1 id="写博文"><a href="#写博文" class="headerlink" title="写博文"></a>写博文</h1><h2 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h2><ul>
<li><strong>创建新博文</strong><br><code>hexo new &lt;title&gt;</code><br>后，<code>source/_posts</code>目录下会生成相应的.md文件，接下来我们可以编辑该文件。  </li>
<li><strong>关于在博文中插入图片</strong><br>可以把图片统一放置在<code>source/images</code>目录下，然后在使用时用下述方式引用：  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](/images/image.jpg)</span><br></pre></td></tr></table></figure>
后续介绍其他方法。  </li>
</ul>
<h2 id="安装hexo-admin插件编辑博文"><a href="#安装hexo-admin插件编辑博文" class="headerlink" title="安装hexo-admin插件编辑博文"></a>安装hexo-admin插件编辑博文</h2><ul>
<li><p><strong>安装插件</strong><br>项目根目录下输入<code>npm install --save hexo-admin</code></p>
</li>
<li><p><strong>启动服务器</strong><br><code>hexo server -d</code><br>在 <a href="http://localhost:4000/admin/" target="_blank" rel="noopener">http://localhost:4000/admin/</a> 中访问。</p>
</li>
<li><p><strong>修改根目录_config.yml文档中deploy的配置</strong><br>文档末输入 :</p>
<pre><code>admin:
  deployCommand: hexo-publish.bat
</code></pre></li>
<li><p><strong>创建bat文件</strong><br>项目根目录下新建<code>hexo-publish.bat</code>文件，文件内容如下：</p>
<pre><code>hexo g -d
</code></pre></li>
<li><p><strong>关于在博文中插入图片方法（但我失败了）</strong><br>hexo admin可以直接复制图片粘贴，然后自动下载到<code>source/images</code>目录并重命名。但在Windows中粘贴后会出现裂图。这时就需要手动把括号中的前后两个斜杠去掉，就能正常显示，如：  </p>
<img src="/2020/01/22/%E3%80%90Hexo%E3%80%91Hexo-github%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/pasted-2.png" class>
</li>
<li><p><strong>上传</strong><br>编辑完毕后，就可以点击Deploy。</p>
</li>
</ul>
<h2 id="安装hexo-asset-image上传图片"><a href="#安装hexo-asset-image上传图片" class="headerlink" title="安装hexo-asset-image上传图片"></a>安装hexo-asset-image上传图片</h2><ul>
<li><strong>安装插件</strong><br>项目根目录下输入<code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></li>
<li><strong>修改根目录_config.yml文档中的配置</strong><br>在根目录下配置文件<code>_config.yml</code>中有<code>post_asset_folder:false</code>改为<code>true</code>。</li>
<li><strong>创建与博文同名文件夹</strong><br>运行<code>hexo new &quot;文章名称&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>文章名称.md</code>文件还有一个同名的文件夹，把图片放入该文件夹。</li>
<li><strong>插入图片</strong><br>随后用下述命令插入图片:<pre><code>{% asset_img test.jpg This is an test image %}
</code></pre>
其中<code>test.jpg</code>就是引用的图片，后面的<code>This is an test image</code>是图片描述。  </li>
</ul>
<h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p>关于主题的使用，也可以查看其他关于Hexo相关文章。<br><a href="http://wangwlj.com/2017/09/09/blog-opti/" target="_blank" rel="noopener">Hexo搭建的GitHub博客之优化</a><br><a href="https://www.jianshu.com/p/e4db4f7ed45f" target="_blank" rel="noopener">Hexo搭建GitHub博客—打造炫酷的NexT主题–高级(三)</a><br><a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">Hexo使用攻略-添加分类及标签</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Cymbym</title>
    <url>/2020/01/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://cymbym.github.io/" target="_blank" rel="noopener">Cymbym</a>! </p>
<h2 id="About-Me"><a href="#About-Me" class="headerlink" title="About Me"></a>About Me</h2><p>XINBIN SHEN received the B.S. degree in communication engineering from the Beijing University of Posts and Telecommunications, China, where he is currently pursuing the M.S. degree in electronic and communication engineering. His current research interests include Wi-Fi sensing, machine learning, and deep learning.</p>
<h2 id="News"><a href="#News" class="headerlink" title="News"></a>News</h2><p>Jul., 2018: Joined Beijing Key Laboratory of Network System Architecture and Convergence, Beijing University of Posts and Telecommunications. Started doing research on Wi-Fi sensing.<br>Jun., 2018: Graduated from Beijing University of Posts and Telecommunications.</p>
<h2 id="Publications"><a href="#Publications" class="headerlink" title="Publications"></a>Publications</h2><p>WiRIM: Resolution Improving Mechanism for Human Sensing With Commodity Wi-Fi<br>WiRoI: Spatial Region of Interest Human Sensing with Commodity WiFi</p>
]]></content>
  </entry>
</search>
